# This is a postgres regress test suite.
# https://github.com/postgres/postgres/blob/master/src/test/regress/sql/bit.sql
# Adapted to sqllogictest format
# PGDIFF comments call out differences between PG and CRDB and/or lack of support.

#
# BIT types
#

#
# Build tables for testing
#
statement ok
CREATE TABLE BIT_TABLE(b BIT(11));

statement error pq: bit string length 2 does not match type BIT\(11\)
INSERT INTO BIT_TABLE VALUES (B'10'); -- too short

statement ok
INSERT INTO BIT_TABLE VALUES (B'00000000000');
INSERT INTO BIT_TABLE VALUES (B'11011000000');
INSERT INTO BIT_TABLE VALUES (B'01010101010');

statement error pq: bit string length 12 does not match type BIT\(11\)
INSERT INTO BIT_TABLE VALUES (B'101011111010'); -- too long

#INSERT INTO BIT_TABLE VALUES ('X554');
#INSERT INTO BIT_TABLE VALUES ('X555');

query T rowsort
SELECT * FROM BIT_TABLE;
----
00000000000
11011000000
01010101010

statement ok
CREATE TABLE VARBIT_TABLE(v BIT VARYING(11));
INSERT INTO VARBIT_TABLE VALUES (B'');
INSERT INTO VARBIT_TABLE VALUES (B'0');
INSERT INTO VARBIT_TABLE VALUES (B'010101');
INSERT INTO VARBIT_TABLE VALUES (B'01010101010');

statement error pq: bit string length 12 too large for type VARBIT\(11\)
INSERT INTO VARBIT_TABLE VALUES (B'101011111010'); -- too long

#INSERT INTO VARBIT_TABLE VALUES ('X554');
#INSERT INTO VARBIT_TABLE VALUES ('X555');

query T rowsort
SELECT * FROM VARBIT_TABLE;
----
·
0
010101
01010101010

# Concatenation
query TTT rowsort
SELECT v, b, (v || b) AS concat
       FROM BIT_TABLE, VARBIT_TABLE
       ORDER BY 3;
----
·            00000000000  00000000000
0            00000000000  000000000000
0            01010101010  001010101010
010101       00000000000  01010100000000000
·            01010101010  01010101010
01010101010  00000000000  0101010101000000000000
01010101010  01010101010  0101010101001010101010
010101       01010101010  01010101010101010
01010101010  11011000000  0101010101011011000000
010101       11011000000  01010111011000000
0            11011000000  011011000000
·            11011000000  11011000000

# PGDIFF: CRDB doesn't support length of BIT type. (#45847)
# Length
#query TT
#SELECT b, length(b) AS lb
#       FROM BIT_TABLE;
#----
#00000000000  11
#11011000000  11
#01010101010  11
#
#query TT
#SELECT v, length(v) AS lv
#       FROM VARBIT_TABLE;
#----
#·             0
#0             1
#010101        6
#01010101010  11

# PGDIFF: CRDB doesn't support SUBSTRING on bit types. (#45848)
# Substring
#query IIII
#SELECT b,
#       SUBSTRING(b FROM 2 FOR 4) AS sub_2_4,
#       SUBSTRING(b FROM 7 FOR 13) AS sub_7_13,
#       SUBSTRING(b FROM 6) AS sub_6
#       FROM BIT_TABLE;
#----
#00000000000  0000  00000  000000
#11011000000  1011  00000  000000
#01010101010  1010  01010  101010
#
#
#query IIII
#SELECT v,
#       SUBSTRING(v FROM 2 FOR 4) AS sub_2_4,
#       SUBSTRING(v FROM 7 FOR 13) AS sub_7_13,
#       SUBSTRING(v FROM 6) AS sub_6
#       FROM VARBIT_TABLE;
#----
#             |         |          |
# 0           |         |          |
# 010101      | 1010    |          | 1
# 01010101010 | 1010    | 01010    | 101010

# Bit operations
statement ok
DROP TABLE varbit_table;
CREATE TABLE varbit_table (a BIT VARYING(16), b BIT VARYING(16));
INSERT INTO varbit_table VALUES
    (0x0f::varbit(8), 0x10::varbit(8)),
    (0x1f::varbit(8), 0x11::varbit(8)),
    (0x2f::varbit(8), 0x12::varbit(8)),
    (0x3f::varbit(8), 0x13::varbit(8)),
    (0x8f::varbit(8), 0x04::varbit(8)),
    (0x000f::varbit(16), 0x0010::varbit(16)),
    (0x0123::varbit(16), 0xffff::varbit(16)),
    (0x2468::varbit(16), 0x2468::varbit(16)),
    (0xfa50::varbit(16), 0x05af::varbit(16)),
    (0x1234::varbit(16), 0xfff5::varbit(16))

query TTTTTT rowsort
SELECT a, b, ~a AS "~ a", a & b AS "a & b",
       a | b AS "a | b", a # b AS "a # b" FROM varbit_table;
----
00001111          00010000          11110000          00000000          00011111          00011111
00011111          00010001          11100000          00010001          00011111          00001110
00101111          00010010          11010000          00000010          00111111          00111101
00111111          00010011          11000000          00010011          00111111          00101100
10001111          00000100          01110000          00000100          10001111          10001011
0000000000001111  0000000000010000  1111111111110000  0000000000000000  0000000000011111  0000000000011111
0000000100100011  1111111111111111  1111111011011100  0000000100100011  1111111111111111  1111111011011100
0010010001101000  0010010001101000  1101101110010111  0010010001101000  0010010001101000  0000000000000000
1111101001010000  0000010110101111  0000010110101111  0000000000000000  1111111111111111  1111111111111111
0001001000110100  1111111111110101  1110110111001011  0001001000110100  1111111111110101  1110110111000001

query TTBBBBBB rowsort
SELECT a,b,a<b AS "a<b",a<=b AS "a<=b",a=b AS "a=b",
        a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM varbit_table
----
00001111          00010000          true   true   false  false  false  true
00011111          00010001          false  false  false  true   true   true
00101111          00010010          false  false  false  true   true   true
00111111          00010011          false  false  false  true   true   true
10001111          00000100          false  false  false  true   true   true
0000000000001111  0000000000010000  true   true   false  false  false  true
0000000100100011  1111111111111111  true   true   false  false  false  true
0010010001101000  0010010001101000  false  true   true   true   false  false
1111101001010000  0000010110101111  false  false  false  true   true   true
0001001000110100  1111111111110101  true   true   false  false  false  true

query TTTT rowsort
SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM varbit_table;
----
00001111          11110000          00010000          00000100
00011111          11110000          00010001          00000100
00101111          11110000          00010010          00000100
00111111          11110000          00010011          00000100
10001111          11110000          00000100          00000001
0000000000001111  0000000011110000  0000000000010000  0000000000000100
0000000100100011  0001001000110000  1111111111111111  0011111111111111
0010010001101000  0100011010000000  0010010001101000  0000100100011010
1111101001010000  1010010100000000  0000010110101111  0000000101101011
0001001000110100  0010001101000000  1111111111110101  0011111111111101

statement ok
DROP TABLE varbit_table;

# Bit operations
statement ok
DROP TABLE bit_table;
CREATE TABLE bit_table (a BIT(16), b BIT(16));
INSERT INTO bit_table VALUES
    (0x0f00::bit(16), 0x1000::bit(16)),
    (0x1f00::bit(16), 0x1100::bit(16)),
    (0x2f00::bit(16), 0x1200::bit(16)),
    (0x3f00::bit(16), 0x1300::bit(16)),
    (0x8f00::bit(16), 0x0400::bit(16)),
    (0x000f::bit(16), 0x0010::bit(16)),
    (0x0123::bit(16), 0xffff::bit(16)),
    (0x2468::bit(16), 0x2468::bit(16)),
    (0xfa50::bit(16), 0x05af::bit(16)),
    (0x1234::bit(16), 0xfff5::bit(16))

query TTTTTT rowsort
SELECT a,b,~a AS "~ a",a & b AS "a & b",
	a|b AS "a | b", a # b AS "a # b" FROM bit_table;
----
0000111100000000  0001000000000000  1111000011111111  0000000000000000  0001111100000000  0001111100000000
0001111100000000  0001000100000000  1110000011111111  0001000100000000  0001111100000000  0000111000000000
0010111100000000  0001001000000000  1101000011111111  0000001000000000  0011111100000000  0011110100000000
0011111100000000  0001001100000000  1100000011111111  0001001100000000  0011111100000000  0010110000000000
1000111100000000  0000010000000000  0111000011111111  0000010000000000  1000111100000000  1000101100000000
0000000000001111  0000000000010000  1111111111110000  0000000000000000  0000000000011111  0000000000011111
0000000100100011  1111111111111111  1111111011011100  0000000100100011  1111111111111111  1111111011011100
0010010001101000  0010010001101000  1101101110010111  0010010001101000  0010010001101000  0000000000000000
1111101001010000  0000010110101111  0000010110101111  0000000000000000  1111111111111111  1111111111111111
0001001000110100  1111111111110101  1110110111001011  0001001000110100  1111111111110101  1110110111000001

query TTBBBBBB rowsort
SELECT a,b,a<b AS "a<b",a<=b AS "a<=b",a=b AS "a=b",
        a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM bit_table;
----
0000111100000000  0001000000000000  true   true    false  false   false  true
0001111100000000  0001000100000000  false  false   false  true    true   true
0010111100000000  0001001000000000  false  false   false  true    true   true
0011111100000000  0001001100000000  false  false   false  true    true   true
1000111100000000  0000010000000000  false  false   false  true    true   true
0000000000001111  0000000000010000  true   true    false  false   false  true
0000000100100011  1111111111111111  true   true    false  false   false  true
0010010001101000  0010010001101000  false  true    true   true    false  false
1111101001010000  0000010110101111  false  false   false  true    true   true
0001001000110100  1111111111110101  true   true    false  false   false  true

query TTTT rowsort
SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM bit_table;
----
0000111100000000  1111000000000000  0001000000000000  0000010000000000
0001111100000000  1111000000000000  0001000100000000  0000010001000000
0010111100000000  1111000000000000  0001001000000000  0000010010000000
0011111100000000  1111000000000000  0001001100000000  0000010011000000
1000111100000000  1111000000000000  0000010000000000  0000000100000000
0000000000001111  0000000011110000  0000000000010000  0000000000000100
0000000100100011  0001001000110000  1111111111111111  0011111111111111
0010010001101000  0100011010000000  0010010001101000  0000100100011010
1111101001010000  1010010100000000  0000010110101111  0000000101101011
0001001000110100  0010001101000000  1111111111110101  0011111111111101

statement ok
DROP TABLE bit_table;

# The following should fail
statement error cannot AND bit strings of different sizes
select B'001' & B'10';

statement error cannot OR bit strings of different sizes
select B'0111' | B'011';

statement error cannot XOR bit strings of different sizes
select B'0010' # B'011101';

# PGDIFF: CRDB does not support POSITION with bit types (#45849)
# More position tests, checking all the boundary cases
#query I
#SELECT POSITION(B'1010' IN B'0000101');   -- 0
#----
#0
#
#query I
#SELECT POSITION(B'1010' IN B'00001010');  -- 5
#----
#5
#
#query I
#SELECT POSITION(B'1010' IN B'00000101');  -- 0
#----
#0
#
#query I
#SELECT POSITION(B'1010' IN B'000001010');  -- 6
#----
#6
#
#query I
#SELECT POSITION(B'' IN B'00001010');  -- 1
#----
#1
#
#query I
#SELECT POSITION(B'0' IN B'');  -- 0
#----
#0
#
#query I
#SELECT POSITION(B'' IN B'');  -- 0
#----
#0
#
#query I
#SELECT POSITION(B'101101' IN B'001011011011011000');  -- 3
#----
#3
#
#query I
#SELECT POSITION(B'10110110' IN B'001011011011010');  -- 3
#----
#3
#
#query I
#SELECT POSITION(B'1011011011011' IN B'001011011011011');  -- 3
#----
#3
#
#query I
#SELECT POSITION(B'1011011011011' IN B'00001011011011011');  -- 5
#----
#5
#
#query I
#SELECT POSITION(B'11101011' IN B'11101011'); -- 1
#----
#1
#
#query I
#SELECT POSITION(B'11101011' IN B'011101011'); -- 2
#----
#2
#
#query I
#SELECT POSITION(B'11101011' IN B'00011101011'); -- 4
#----
#4
#
#query I
#SELECT POSITION(B'11101011' IN B'0000011101011'); -- 6
#----
#6
#
#query I
#SELECT POSITION(B'111010110' IN B'111010110'); -- 1
#----
#1
#
#query I
#SELECT POSITION(B'111010110' IN B'0111010110'); -- 2
#----
#2
#
#query I
#SELECT POSITION(B'111010110' IN B'000111010110'); -- 4
#----
#4
#
#query I
#SELECT POSITION(B'111010110' IN B'00000111010110'); -- 6
#----
#6
#
#query I
#SELECT POSITION(B'111010110' IN B'11101011'); -- 0
#----
#0
#
#query I
#SELECT POSITION(B'111010110' IN B'011101011'); -- 0
#----
#0
#
#query I
#SELECT POSITION(B'111010110' IN B'00011101011'); -- 0
#----
#0
#
#query I
#SELECT POSITION(B'111010110' IN B'0000011101011'); -- 0
#----
#0
#
#query I
#SELECT POSITION(B'111010110' IN B'111010110'); -- 1
#----
#1
#
#query I
#SELECT POSITION(B'111010110' IN B'0111010110'); -- 2
#----
#2
#
#query I
#SELECT POSITION(B'111010110' IN B'000111010110'); -- 4
#----
#4
#
#query I
#SELECT POSITION(B'111010110' IN B'00000111010110'); -- 6
#----
#6
#
#query I
#SELECT POSITION(B'111010110' IN B'000001110101111101011'); -- 0
#----
#0
#
#query I
#SELECT POSITION(B'111010110' IN B'0000001110101111101011'); -- 0
#----
#0
#
#query I
#SELECT POSITION(B'111010110' IN B'000000001110101111101011'); -- 0
#----
#0
#
#query I
#SELECT POSITION(B'111010110' IN B'00000000001110101111101011'); -- 0
#----
#0
#
#query I
#SELECT POSITION(B'111010110' IN B'0000011101011111010110'); -- 14
#----
#14
#
#query I
#SELECT POSITION(B'111010110' IN B'00000011101011111010110'); -- 15
#----
#15
#
#query I
#SELECT POSITION(B'111010110' IN B'0000000011101011111010110'); -- 17
#----
#17
#
#query I
#SELECT POSITION(B'111010110' IN B'000000000011101011111010110'); -- 19
#----
#19
#
#query I
#SELECT POSITION(B'000000000011101011111010110' IN B'000000000011101011111010110'); -- 1
#----
#1
#
#query I
#SELECT POSITION(B'00000000011101011111010110' IN B'000000000011101011111010110'); -- 2
#----
#2
#
#query I
#SELECT POSITION(B'0000000000011101011111010110' IN B'000000000011101011111010110'); -- 0
#----
#0

# Shifting
statement ok
CREATE TABLE BIT_SHIFT_TABLE(b BIT(16));
INSERT INTO BIT_SHIFT_TABLE VALUES (B'1101100000000000');
INSERT INTO BIT_SHIFT_TABLE SELECT b>>1 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>2 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>4 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>8 FROM BIT_SHIFT_TABLE;

# PGDIFF: CRDB does not support POSITION with bit types (#45849)
#query IIT
#SELECT POSITION(B'1101' IN b),
#       POSITION(B'11011' IN b),
#       b
#       FROM BIT_SHIFT_TABLE ;
#----
#        1 |        1 | 1101100000000000
#        2 |        2 | 0110110000000000
#        3 |        3 | 0011011000000000
#        4 |        4 | 0001101100000000
#        5 |        5 | 0000110110000000
#        6 |        6 | 0000011011000000
#        7 |        7 | 0000001101100000
#        8 |        8 | 0000000110110000
#        9 |        9 | 0000000011011000
#       10 |       10 | 0000000001101100
#       11 |       11 | 0000000000110110
#       12 |       12 | 0000000000011011
#       13 |        0 | 0000000000001101
#        0 |        0 | 0000000000000110
#        0 |        0 | 0000000000000011
#        0 |        0 | 0000000000000001

query TTT rowsort
SELECT b, b >> 1 AS bsr, b << 1 AS bsl
       FROM BIT_SHIFT_TABLE ;
----
1101100000000000  0110110000000000  1011000000000000
0110110000000000  0011011000000000  1101100000000000
0011011000000000  0001101100000000  0110110000000000
0001101100000000  0000110110000000  0011011000000000
0000110110000000  0000011011000000  0001101100000000
0000011011000000  0000001101100000  0000110110000000
0000001101100000  0000000110110000  0000011011000000
0000000110110000  0000000011011000  0000001101100000
0000000011011000  0000000001101100  0000000110110000
0000000001101100  0000000000110110  0000000011011000
0000000000110110  0000000000011011  0000000001101100
0000000000011011  0000000000001101  0000000000110110
0000000000001101  0000000000000110  0000000000011010
0000000000000110  0000000000000011  0000000000001100
0000000000000011  0000000000000001  0000000000000110
0000000000000001  0000000000000000  0000000000000010

query TTT rowsort
SELECT b, b >> 8 AS bsr8, b << 8 AS bsl8
       FROM BIT_SHIFT_TABLE ;
----
1101100000000000  0000000011011000  0000000000000000
0110110000000000  0000000001101100  0000000000000000
0011011000000000  0000000000110110  0000000000000000
0001101100000000  0000000000011011  0000000000000000
0000110110000000  0000000000001101  1000000000000000
0000011011000000  0000000000000110  1100000000000000
0000001101100000  0000000000000011  0110000000000000
0000000110110000  0000000000000001  1011000000000000
0000000011011000  0000000000000000  1101100000000000
0000000001101100  0000000000000000  0110110000000000
0000000000110110  0000000000000000  0011011000000000
0000000000011011  0000000000000000  0001101100000000
0000000000001101  0000000000000000  0000110100000000
0000000000000110  0000000000000000  0000011000000000
0000000000000011  0000000000000000  0000001100000000
0000000000000001  0000000000000000  0000000100000000

query TTT rowsort
SELECT b::bit(15), b::bit(15) >> 1 AS bsr, b::bit(15) << 1 AS bsl
       FROM BIT_SHIFT_TABLE ;
----
110110000000000  011011000000000  101100000000000
011011000000000  001101100000000  110110000000000
001101100000000  000110110000000  011011000000000
000110110000000  000011011000000  001101100000000
000011011000000  000001101100000  000110110000000
000001101100000  000000110110000  000011011000000
000000110110000  000000011011000  000001101100000
000000011011000  000000001101100  000000110110000
000000001101100  000000000110110  000000011011000
000000000110110  000000000011011  000000001101100
000000000011011  000000000001101  000000000110110
000000000001101  000000000000110  000000000011010
000000000000110  000000000000011  000000000001100
000000000000011  000000000000001  000000000000110
000000000000001  000000000000000  000000000000010
000000000000000  000000000000000  000000000000000

query TTT rowsort
SELECT b::bit(15), b::bit(15) >> 8 AS bsr8, b::bit(15) << 8 AS bsl8
       FROM BIT_SHIFT_TABLE ;
----
110110000000000  000000001101100  000000000000000
011011000000000  000000000110110  000000000000000
001101100000000  000000000011011  000000000000000
000110110000000  000000000001101  000000000000000
000011011000000  000000000000110  100000000000000
000001101100000  000000000000011  110000000000000
000000110110000  000000000000001  011000000000000
000000011011000  000000000000000  101100000000000
000000001101100  000000000000000  110110000000000
000000000110110  000000000000000  011011000000000
000000000011011  000000000000000  001101100000000
000000000001101  000000000000000  000110100000000
000000000000110  000000000000000  000011000000000
000000000000011  000000000000000  000001100000000
000000000000001  000000000000000  000000100000000
000000000000000  000000000000000  000000000000000

# PGDIFF: Bug in CRDB casting to VARBIT (#45850) causes wrong data to be inserted.
statement ok
CREATE TABLE VARBIT_SHIFT_TABLE(v BIT VARYING(20));
INSERT INTO VARBIT_SHIFT_TABLE VALUES (B'11011');
INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0' AS BIT VARYING(6)) >>1 FROM VARBIT_SHIFT_TABLE;
INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00' AS BIT VARYING(8)) >>2 FROM VARBIT_SHIFT_TABLE;
INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0000' AS BIT VARYING(12)) >>4 FROM VARBIT_SHIFT_TABLE;
INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00000000' AS BIT VARYING(20)) >>8 FROM VARBIT_SHIFT_TABLE;

# PGDIFF: CRDB does not support POSITION with bit types (#45849)
#query IIT rowsort
#SELECT POSITION(B'1101' IN v),
#       POSITION(B'11011' IN v),
#       v
#       FROM VARBIT_SHIFT_TABLE ;
#----
#        1 |        1 | 11011
#        2 |        2 | 011011
#        3 |        3 | 0011011
#        4 |        4 | 00011011
#        5 |        5 | 000011011
#        6 |        6 | 0000011011
#        7 |        7 | 00000011011
#        8 |        8 | 000000011011
#        9 |        9 | 0000000011011
#       10 |       10 | 00000000011011
#       11 |       11 | 000000000011011
#       12 |       12 | 0000000000011011
#       13 |       13 | 00000000000011011
#       14 |       14 | 000000000000011011
#       15 |       15 | 0000000000000011011
#       16 |       16 | 00000000000000011011

#query TTT rowsort
#SELECT v, v >> 1 AS vsr, v << 1 AS vsl
#       FROM VARBIT_SHIFT_TABLE ;
#----
#11011                 01101                 10110
#011011                001101                110110
#0011011               0001101               0110110
#00011011              00001101              00110110
#000011011             000001101             000110110
#0000011011            0000001101            0000110110
#00000011011           00000001101           00000110110
#000000011011          000000001101          000000110110
#0000000011011         0000000001101         0000000110110
#00000000011011        00000000001101        00000000110110
#000000000011011       000000000001101       000000000110110
#0000000000011011      0000000000001101      0000000000110110
#00000000000011011     00000000000001101     00000000000110110
#000000000000011011    000000000000001101    000000000000110110
#0000000000000011011   0000000000000001101   0000000000000110110
#00000000000000011011  00000000000000001101  00000000000000110110

#query TTT rowsort
#SELECT v, v >> 8 AS vsr8, v << 8 AS vsl8
#       FROM VARBIT_SHIFT_TABLE ;
#----
#11011                 00000                 00000
#011011                000000                000000
#0011011               0000000               0000000
#00011011              00000000              00000000
#000011011             000000000             100000000
#0000011011            0000000000            1100000000
#00000011011           00000000000           01100000000
#000000011011          000000000000          101100000000
#0000000011011         0000000000000         1101100000000
#00000000011011        00000000000000        01101100000000
#000000000011011       000000000000000       001101100000000
#0000000000011011      0000000000000000      0001101100000000
#00000000000011011     00000000000000000     00001101100000000
#000000000000011011    000000000000000000    000001101100000000
#0000000000000011011   0000000000000000000   0000001101100000000
#00000000000000011011  00000000000000000000  00000001101100000000

statement ok
DROP TABLE BIT_SHIFT_TABLE;
DROP TABLE VARBIT_SHIFT_TABLE;

# PGDIFF: CRDB does not support the get_bit and set_bit functions. (#45851)
# Get/Set bit
#query T
#SELECT get_bit(B'0101011000100', 10);
#----
#1
#
#query T
#SELECT set_bit(B'0101011000100100', 15, 1);
#----
#0101011000100101
#
#query error bit index 16 out of valid range (0..15)
#SELECT set_bit(B'0101011000100100', 16, 1);	-- fail

# PGDIFF: CRDB does not support the overlay function.
# Overlay
#SELECT overlay(B'0101011100' placing '001' from 2 for 3);
#----
#0001011100
#
#SELECT overlay(B'0101011100' placing '101' from 6);
#  overlay
#----
# 0101010100
#(1 row)
#
#SELECT overlay(B'0101011100' placing '001' from 11);
#    overlay
#------
# 0101011100001
#(1 row)
#
#SELECT overlay(B'0101011100' placing '001' from 20);
#    overlay
#------
# 0101011100001
#(1 row)
#

# This table is intentionally left around to exercise pg_dump/pg_upgrade
statement ok
CREATE TABLE bit_defaults(
  b1 bit(4) DEFAULT '1001',
  b2 bit(4) DEFAULT B'0101',
  b3 bit varying(5) DEFAULT '1001',
  b4 bit varying(5) DEFAULT B'0101'
);

statement ok
INSERT INTO bit_defaults DEFAULT VALUES;

query TTTT
TABLE bit_defaults;
----
1001  0101  1001  0101

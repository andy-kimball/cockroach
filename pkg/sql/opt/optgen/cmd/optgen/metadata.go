// Copyright 2018 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package main

import (
	"fmt"
	"strings"

	"github.com/cockroachdb/cockroach/pkg/sql/opt/optgen/lang"
)

// metadata generates and stores the mapping from Optgen language expressions to
// the Go types that the code generators use to implement those expressions. In
// addition, when generating strongly-typed Go code, it is often necessary to
// insert casts, struct referencing (&), and pointer dereferences (*). Since the
// Optgen code generators do not have access to regular Go metadata for these
// types, aspects of it must be replicated here.
type metadata struct {
	compiled  *lang.CompiledExpr
	types     map[string]*typeDef
	exprTypes map[lang.Expr]*typeDef
}

/*
type opDef struct {
	name        string
	typ         *typeDef
	children    []*fieldDef
	private     *fieldDef
	rawPrivates []*fieldDef
	rawFields   []*fieldDef
}

type fieldDef struct {
	name string
	typ  *typeDef
}
*/
// typeDef describes the name and characteristics of each Go type used by the
// code generators. This is used by the Optgen code generators to generate
// correct strongly-typed code.
type typeDef struct {
	// name is the correctly qualified Go name of the type, as it should appear
	// in the current package. For example, if the current package is "memo":
	//
	//   RelNode
	//   opt.Node
	//   FiltersNode
	//   ScanLimit
	//   *tree.Subquery
	//   types.T
	//
	name string

	// fullName is the fully qualified Go name of the type, irrespective of the
	// current package. For example, if the current package is "memo":
	//
	//   memo.RelNode
	//   opt.Node
	//   memo.FiltersNode
	//   memo.ScanLimit
	//   *tree.Subquery
	//   types.T
	//
	fullName string

	// friendlyName is a human-friendly name for the type that is a simple
	// identifier having no special characters like "." or "*". It is used in .opt
	// files to refer to types without needing package names and type modifiers
	// like "*". It's also used to generate methods based on the type, like Intern
	// methods, where special characters are not allowed. For example:
	//
	//   RelNode
	//   Node
	//   FiltersNode
	//   ScanLimit
	//   Subquery
	//   DatumType
	//
	friendlyName string

	// isNode is true if the type is either one of the node-related interfaces
	// (opt.Node, memo.RelNode, opt.ScalarExpr), or one of the auto-generated
	// node types (memo.ScanNode, memo.AndExpr, etc.).
	isNode bool

	// isPointer is true if the type is a Go pointer or interface type (types.T,
	// memo.RelNode, *tree.Subquery, etc.).
	isPointer bool

	// passByVal is true if the type should be passed by value to custom functions,
	// as well as stored by value in structs and variables.
	passByVal bool

	// isGenerated is true if the type's definition was auto-generated by Optgen,
	// vs. manually defined.
	isGenerated bool

	// listItemType links to the type of items in the list, if this type is a
	// a list type (e.g. memo.FiltersExpr). If this is not a list type, then
	// listItemType is nil.
	listItemType *typeDef
}

// isListType is true if this type is represented as a Go slice. For example:
//
//   type FiltersExpr []FiltersItem
//
func (t *typeDef) isListType() bool {
	return t.listItemType != nil
}

func (t *typeDef) asParam() string {
	if t.passByVal {
		return t.name
	}
	return fmt.Sprintf("*%s", t.name)
}

func newMetadata(compiled *lang.CompiledExpr, pkg string) *metadata {
	md := &metadata{
		compiled:  compiled,
		types:     make(map[string]*typeDef),
		exprTypes: make(map[lang.Expr]*typeDef),
	}

	// Add all types used in Optgen defines here.
	md.types = map[string]*typeDef{
		"RelNode":        {fullName: "memo.RelNode", isNode: true, isPointer: true},
		"Node":           {fullName: "opt.Node", isNode: true, isPointer: true},
		"ScalarExpr":     {fullName: "opt.ScalarExpr", isNode: true, isPointer: true},
		"Operator":       {fullName: "opt.Operator", passByVal: true},
		"ColumnID":       {fullName: "opt.ColumnID", passByVal: true},
		"ColSet":         {fullName: "opt.ColSet", passByVal: true},
		"ColList":        {fullName: "opt.ColList", passByVal: true},
		"TableID":        {fullName: "opt.TableID", passByVal: true},
		"Ordering":       {fullName: "opt.Ordering", passByVal: true},
		"OrderingChoice": {fullName: "props.OrderingChoice", passByVal: true},
		"TupleOrdinal":   {fullName: "memo.TupleOrdinal", passByVal: true},
		"ScanLimit":      {fullName: "memo.ScanLimit", passByVal: true},
		"ScanFlags":      {fullName: "memo.ScanFlags", passByVal: true},
		"ExplainOptions": {fullName: "tree.ExplainOptions", passByVal: true},
		"ShowTraceType":  {fullName: "tree.ShowTraceType", passByVal: true},
		"bool":           {fullName: "bool", passByVal: true},
		"int":            {fullName: "int", passByVal: true},
		"string":         {fullName: "string", passByVal: true},
		"DatumType":      {fullName: "types.T", isPointer: true},
		"ColType":        {fullName: "coltypes.T", isPointer: true},
		"Datum":          {fullName: "tree.Datum", isPointer: true},
		"TypedExpr":      {fullName: "tree.TypedExpr", isPointer: true},
		"Subquery":       {fullName: "*tree.Subquery", isPointer: true},
		"Constraint":     {fullName: "*constraint.Constraint", isPointer: true},
		"FuncProps":      {fullName: "*tree.FunctionProperties", isPointer: true},
		"FuncOverload":   {fullName: "*tree.Overload", isPointer: true},
		"PhysProps":      {fullName: "*props.Physical", isPointer: true},
		"RelProps":       {fullName: "props.Relational"},
		"ScalarProps":    {fullName: "props.Scalar"},
	}

	// Add types of generated op and private structs.
	for _, define := range compiled.Defines {
		// Derive friendly name of type.
		var friendlyName string
		if define.Tags.Contains("ListItem") || define.Tags.Contains("Private") {
			friendlyName = string(define.Name)
		} else if define.Tags.Contains("Scalar") {
			friendlyName = fmt.Sprintf("%sExpr", define.Name)
		} else {
			friendlyName = fmt.Sprintf("%sNode", define.Name)
		}

		fullName := fmt.Sprintf("memo.%s", friendlyName)
		typ := &typeDef{fullName: fullName, isGenerated: true}
		if !define.Tags.Contains("Private") {
			typ.isNode = true
		}
		if define.Tags.Contains("List") {
			typ.passByVal = true
		}

		md.types[friendlyName] = typ
		md.exprTypes[define] = typ
	}

	// 1. Associate each DefineField with its type.
	// 2. Link list types to the types of their list items.
	for _, define := range compiled.Defines {
		// Associate each DefineField with its type.
		for _, field := range define.Fields {
			md.exprTypes[field] = md.lookupType(string(field.Type))
		}

		if define.Tags.Contains("List") {
			listTyp := md.typeOf(define)
			itemTyp := md.lookupType(fmt.Sprintf("%sItem", define.Name))
			if itemTyp != nil {
				listTyp.listItemType = itemTyp
			} else {
				listTyp.listItemType = md.lookupType("ScalarExpr")
			}
		}
	}

	// Now walk each type and fill in any remaining fields.
	for friendlyName, typ := range md.types {
		typ.friendlyName = friendlyName

		// Remove package prefix from types in the same package.
		if strings.HasPrefix(typ.fullName, pkg+".") {
			typ.name = typ.fullName[len(pkg)+1:]
		} else {
			typ.name = typ.fullName
		}

		// If type is a pointer/interface, then it should always be passed byref.
		if typ.isPointer {
			typ.passByVal = true
		}
	}

	return md
}

func (m *metadata) typeOf(e lang.Expr) *typeDef {
	return m.exprTypes[e]
}

func (m *metadata) lookupType(name string) *typeDef {
	return m.types[name]
}

func (m *metadata) fieldName(field *lang.DefineFieldExpr) string {
	if field.Name == "_" {
		return string(field.Type)
	}
	return string(field.Name)
}

func (m *metadata) childFields(define *lang.DefineExpr) lang.DefineFieldsExpr {
	// Skip until non-node field is found.
	n := 0
	for _, field := range define.Fields {
		typ := m.typeOf(field)
		if !typ.isNode {
			break
		}
		n++
	}
	return define.Fields[:n]
}

func (m *metadata) privateField(define *lang.DefineExpr) *lang.DefineFieldExpr {
	// Skip until non-node field is found.
	n := 0
	for _, field := range define.Fields {
		typ := m.typeOf(field)
		if !typ.isNode {
			return define.Fields[n]
		}
		n++
	}
	return nil
}

func (m *metadata) fieldLoadPrefix(field *lang.DefineFieldExpr) string {
	if !m.typeOf(field).passByVal {
		return "&"
	}
	return ""
}

func (m *metadata) fieldStorePrefix(field *lang.DefineFieldExpr) string {
	if !m.typeOf(field).passByVal {
		return "*"
	}
	return ""
}

/*
func getFieldDef(opDef *opDef, nth int) *fieldDef {
	var field *fieldDef
	if nth < len(opDef.children) {
		field = opDef.children[nth]
	} else if opDef.private != nil && nth == len(opDef.children) {
		field = opDef.private
	} else {
		panic(fmt.Sprintf("too many arguments to op: %s", opDef.name))
	}
	return field
}
*/
